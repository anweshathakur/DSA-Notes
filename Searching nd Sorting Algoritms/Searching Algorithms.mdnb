{"cells":[{"kind":1,"value":"# Searching Allgorithms","language":"markdown","metadata":{}},{"kind":1,"value":"### **Searching** ","language":"markdown","metadata":{}},{"kind":1,"value":"**1. Linear Search**","language":"markdown","metadata":{}},{"kind":1,"value":"finds an element of array by matching it with every element present.","language":"markdown","metadata":{}},{"kind":1,"value":"**Advantages**\r\n- simplicity & Easier to understand.\r\n- works on both sorted and unsorted.\r\n- doesnot require additional space (memory efficient)\r\n\r\n**Disadvantages**\r\n- insufficient for large datasets.\r\n- better algos avl for sorted data.\r\n\r\n**Use Cases**\r\n- small datasets\r\n- unsorted arrays\r\n- embedded systems or environmentwith less resources. (low overhead)","language":"markdown","metadata":{}},{"kind":2,"value":"```\r\nPseudo Code\r\n```\r\nfunction linearSearch(array, target):\r\n    for i from 0 to length(array) - 1:\r\n        if array[i] == target:\r\n            return i\r\n    return -1\r\n```\r\n```","language":"plaintext","metadata":{}},{"kind":2,"value":"#include <iostream>\r\nusing namespace std;\r\n\r\nint linearSearch(int array[], int size, int target) {\r\n    for (int i = 0; i < size; i++) {\r\n        if (array[i] == target) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nint main() {\r\n    int arr[] = {5, 2, 8, 1, 9};\r\n    int size = 5;\r\n    int target = 8;\r\n    int result = linearSearch(arr, size, target);\r\n    if (result != -1) {\r\n        cout << \"Element found at index: \" << result << endl;\r\n    } else {\r\n        cout << \"Element not found\" << endl;\r\n    }\r\n    return 0;\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"**time complexity :**\r\n1. Best case : O(1)\r\n2. Avg Case: O((N+1)/2)\r\n3. Worst Case: O(N)\r\n\r\n-> Space complexity: O(1)","language":"markdown","metadata":{}},{"kind":1,"value":"**2. Binary Search**","language":"markdown","metadata":{}},{"kind":1,"value":"**Properties**\r\n- works only on sorted arrays.\r\n- reduces search by half each step.\r\n- faster real time application.\r\n\r\n**Time Coplexity**\r\n- O(logn) --> avg and worst case\r\n- O (1) --> best case\r\n\r\n**Use Case**\r\n-  large datasetss\r\n- sorted datasets\r\n- Wide real world applications\r\n","language":"markdown","metadata":{}},{"kind":2,"value":"#Pseudo Code\r\nfunction binarySearch(array, target):\r\n    left = 0\r\n    right = length(array) - 1\r\n    \r\n    while left <= right:\r\n        mid = (left + right) / 2\r\n        if array[mid] == target:\r\n            return mid\r\n        else if array[mid] < target:\r\n            left = mid + 1\r\n        else:\r\n            right = mid - 1\r\n    \r\n    return -1","language":"plaintext","metadata":{}},{"kind":1,"value":"1. Iterative Approach","language":"markdown","metadata":{}},{"kind":2,"value":"#include <iostream>\r\nusing namespace std;\r\nint BinarySearch(int arr[], int size , int target){\r\n    int low = 0;\r\n    int high = size -1 ;\r\n    while (low <= high){\r\n        int mid = (low + high)/2;\r\n        //case 1: target = mid\r\n        if (arr[mid] == target){\r\n            return mid;\r\n        }\r\n    //case 2: target < mid else if (target < arr[mid]){ high = mid -1; } \r\n        else if (arr[mid] > target){\r\n            high = mid - 1;\r\n        }\r\n    //case 3: target > mid else { low = mid + 1;}\r\n        else {\r\n            low = mid+1;\r\n        }\r\n\r\n    }\r\n    return -1;\r\n}\r\nint main(){\r\n    int arr[] = {1,3,7,9,11};\r\n    int size = 5;\r\n    int target = 7;\r\n    int result = BinarySearch(arr, size, target);\r\n    if (result != -1){\r\n        cout << \"Element found at index: \" << result << endl;\r\n    } else {\r\n        cout << \"Element not found\" << endl;\r\n    }\r\nreturn 0;\r\n}\r\n","language":"cpp","metadata":{}},{"kind":1,"value":"2. Recusive Approach","language":"markdown","metadata":{}},{"kind":2,"value":"#include <iostream>\r\nusing namespace std;\r\n\r\nint BinarySearchR(int arr[], int size ,int target){\r\n    int low = 0;\r\n    int high = size -1;\r\n    \r\n    if (low <= high){\r\n        int mid = low +(high- low)/ 2 ; //prevents overflow\r\n\r\n        if (arr[mid] == target){\r\n            return mid;\r\n        }\r\n        else if(arr[mid]< target){\r\n            low = mid +1;\r\n            return BinarySearchR(arr, size, target);\r\n        }\r\n        else {\r\n            high = mid - 1;\r\n            return BinarySearchR(arr, size, target);\r\n\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nint main(){\r\n    int arr = {1, 2, 5, 6 , 8, 9}\r\n    int n = 6;\r\n    int target = 6;\r\n\r\n    int res = BinarySearchR(arr[], n , target);\r\n    if (res != -1){\r\n        cout << \"Target Found at index:\"<<  res << endl;\r\n    }\r\n    else {\r\n        cout << \"Target not found\" << endl;\r\n    }\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"### Problems","language":"markdown","metadata":{}},{"kind":2,"value":" 1 . \r\n Problem Statement: Search Insert Position\r\nDescription: Given a sorted array of distinct integers and a target value, \r\nreturn the index if the target is found.\r\n If not, return the index where it would be if it were inserted in order.\r\n ;You must write an algorithm with $O(\\log n)$ runtime complexity.\r\n\r\n \r\nExample 1: * \r\nInput: nums = [1, 3, 5, 6],\r\n target = 5\r\n Output: 2\r\n \r\nExample 2: * \r\nInput: nums = [1, 3, 5, 6],\r\n target = 2\r\n Output: 1\r\n(Explanation: 2 is not in the array. \r\nIf inserted, the array would become [1, 2, 3, 5, 6],\r\n putting 2 at index 1.)\r\n\r\nExample 3: * \r\nInput: nums = [1, 3, 5, 6],\r\n target = 7\r\n Output: 4","language":"plaintext","metadata":{}},{"kind":2,"value":"#include <iostream>\r\nusing namespace std;\r\nint BinarySearch(int arr[], int n , int target){\r\n    int low = 0 ; int high = n - 1; \r\n    while(low <= high){\r\n        int mid = low + (high - low) / 2 ;\r\n        if (arr[mid] == target){\r\n            return mid ;\r\n        }\r\n        if (arr[mid ] < target){\r\n            low= mid +1 ;\r\n        }\r\n        else {\r\n            high = mid -1;\r\n        }   \r\n    }\r\n    return low; //index to be inserted  \r\n}\r\n\r\nint main (){\r\n    int arr[] = {1 , 2 ,3 ,4 7, 9, 11};\r\n    int n = 7;\r\n    int target = 7;\r\n\r\n    int res = BinarySearch(arr, n , target);\r\n    if (res != -1){\r\n        cout << \"Target Found at index:\"<<  res << endl;\r\n    }\r\n    else {\r\n        cout << \"Target not found\" << endl;\r\n        cout << \"Target can be inserted at index:\"<<  res << endl;\r\n    }\r\n\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"","language":"markdown","metadata":{}},{"kind":2,"value":"2. Problem Statement:\r\n  First and Last Position Description:\r\n  Given an array of integers nums sorted in non-decreasing order,\r\n  find the starting and ending position of a given target value.\r\n  If the target is not found in the array, return [-1, -1].\r\n  You must design an algorithm with $O(\\log n)$ runtime complexity.\r\n  Example:\r\n\r\n  Input:\r\n  nums = [1, 2, 2, 2, 3],\r\n  target = 2\r\n\r\n  Output:\r\n  First Occurrence: 1, \r\n  Last Occurrence: 3","language":"plaintext","metadata":{}},{"kind":2,"value":"#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint findBound(int arr[], int n, int target, bool isFirst) {\r\n    int low = 0, high = n - 1;\r\n    int result = -1;\r\n\r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n\r\n        if (arr[mid] == target) {\r\n            result = mid; // Record the index\r\n            if (isFirst) {\r\n                high = mid - 1; // Keep looking left\r\n            } else {\r\n                low = mid + 1;  // Keep looking right\r\n            }\r\n        } \r\n        else if (arr[mid] < target) {\r\n            low = mid + 1;\r\n        } \r\n        else {\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    int arr[] = {1, 2, 2, 2, 3};\r\n    int n = 5;\r\n    int target = 2;\r\n\r\n    int first = findBound(arr, n, target, true);\r\n    int last = findBound(arr, n, target, false);\r\n\r\n    cout << \"First Occurrence: \" << first << endl;\r\n    cout << \"Last Occurrence: \" << last << endl;\r\n\r\n    return 0;\r\n}","language":"cpp","metadata":{}},{"kind":2,"value":"1. Search in Rotated Sorted ArrayProblem\r\nStatement: You are given an integer array nums sorted in ascending order\r\n(with distinct values).\r\nPrior to being passed to your function,\r\nnums is possibly rotated at an unknown pivot index k\r\n(e.g., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\r\nGiven the array nums after the possible rotation and an integer target,\r\nreturn the index of target if it is in nums, or -1 if it is not in nums.\r\n\r\nConstraint: You must design an algorithm with $O(\\log n)$ runtime complexity.\r\nKey Insight: In a rotated array, at least one half (left or right) is always sorted.\r\nUse this to decide where the target lies.","language":"plaintext","metadata":{}},{"kind":2,"value":"#include <vector>\r\nusing namespace std;\r\n\r\nint search(vector<int>& nums, int target) {\r\n    int low = 0, high = nums.size() - 1;\r\n    \r\n    while (low <= high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (nums[mid] == target) return mid;\r\n\r\n        // Identify which half is sorted\r\n        if (nums[low] <= nums[mid]) { // Left half is sorted\r\n            if (target >= nums[low] && target < nums[mid])\r\n                high = mid - 1; // Target is in the left half\r\n            else\r\n                low = mid + 1;  // Target is in the right half\r\n        } else { // Right half is sorted\r\n            if (target > nums[mid] && target <= nums[high])\r\n                low = mid + 1;  // Target is in the right half\r\n            else\r\n                high = mid - 1; // Target is in the left half\r\n        }\r\n    }\r\n    return -1;\r\n}","language":"cpp","metadata":{}},{"kind":2,"value":"2. Find Peak ElementProblem Statement:\r\nA peak element is an element that is strictly greater than its neighbors.\r\n Given a 0-indexed integer array nums, find a peak element and return its index.\r\n If the array contains multiple peaks, return the index to any of the peaks.\r\n You may imagine that nums[-1] = nums[n] = -∞. In other words,\r\n an element is always considered to be strictly greater than a neighbor\r\n that is outside the array.\r\n\r\n Constraint: You must write an algorithm that runs in $O(\\log n)$ time.\r\n\r\n Key Insight: This is a \"Binary Search on Answer\" problem.\r\n \r\n If nums[mid] < nums[mid+1], a peak must exist to the right.","language":"plaintext","metadata":{}},{"kind":2,"value":"int findPeakElement(vector<int>& nums) {\r\n    int low = 0, high = nums.size() - 1;\r\n    \r\n    while (low < high) {\r\n        int mid = low + (high - low) / 2;\r\n        if (nums[mid] < nums[mid + 1]) {\r\n            low = mid + 1; // Move toward the peak on the right\r\n        } else {\r\n            high = mid; // This mid could be the peak, or peak is to the left\r\n        }\r\n    }\r\n    return low; // low and high converge to the peak index\r\n}","language":"cpp","metadata":{}},{"kind":2,"value":"3. Find Minimum in Rotated Sorted ArrayProblem Statement:\r\n\r\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times.\r\n For example, the\r\n array nums = [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] if it was rotated 4 times.\r\nGiven the sorted rotated array nums of unique elements,\r\n\r\n return the minimum element of this array.\r\n\r\nConstraint:\r\n You must design an algorithm with $O(\\log n)$ runtime complexity.\r\n \r\nKey Insight:\r\nThe minimum element is the only element that is smaller than its predecessor.","language":"plaintext","metadata":{}},{"kind":2,"value":"int findMin(vector<int>& nums) {\r\n    int low = 0, high = nums.size() - 1;\r\n    \r\n    while (low < high) {\r\n        int mid = low + (high - low) / 2;\r\n        \r\n        // If mid element is greater than high, min must be in the right half\r\n        if (nums[mid] > nums[high]) {\r\n            low = mid + 1;\r\n        } else {\r\n            // If mid element is less than high, mid could be the min\r\n            high = mid;\r\n        }\r\n    }\r\n    return nums[low];\r\n}","language":"cpp","metadata":{}},{"kind":2,"value":"4. Sqrt(x) ImplementationProblem Statement:\r\n\r\n Given a non-negative integer x,\r\n return the square root of x rounded down to the nearest integer.\r\n The returned integer should be non-negative as well.\r\n You must not use any built-in exponent function or operator,\r\n  such as pow(x, 0.5) in C++ or x ** 0.5 in Python.\r\n\r\n  Constraint: Your solution should be more efficient than $O(n)$ (Linear Search).\r\n  Key Insight: The search space is $[0, x]$.\r\n Use Binary Search to find the largest integer $k$ such that $k^2 \\le x$","language":"plaintext","metadata":{}},{"kind":2,"value":"#include <iostream>\r\nusing namespace std;\r\nint mySqrt(int x) {\r\n    if (x < 2) return x;\r\n    \r\n    int low = 1, high = x / 2; // Sqrt of x (where x > 1) is never more than x/2\r\n    int ans;\r\n    \r\n    while (low <= high) {\r\n        long mid = low + (high - low) / 2; // Use long to prevent overflow during mid*mid\r\n        if (mid * mid == x) return mid;\r\n        \r\n        if (mid * mid < x) {\r\n            ans = mid;    // Keep track of the floor value\r\n            low = mid + 1;\r\n        } else {\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    return ans;\r\n}","language":"cpp","metadata":{}},{"kind":2,"value":"Problem Statement\r\n\r\nTom is working in a warehouse inventory system,\r\nwhere the item IDs are assigned sequentially in ascending order. \r\n\r\nHe wants to develop a program using recursive binary search to efficiently \r\ndetermine the closest item ID that is less than or equal to a given target ID. \r\n\r\nThe program takes the total number of items and their sorted IDs as input,\r\nassisting warehouse staff in quickly identifying the closest available item \r\nless than or equal to the target ID. Help Tom in this program.\r\n\r\nInput format :\r\nThe first line of input consists of an integer N, representing\r\n the number of items in the warehouse.\r\nThe second line consists of N space-separated integers,\r\n representing the sorted list of item IDs.\r\nThe third line consists of an integer representing the target item ID.\r\n\r\nOutput format :\r\nThe output prints \"The closest item ID less than or equal to X is Y\",\r\n where X is the target ID and Y is the closest item ID less than or equal to X.\r\nIf no such element exists, \r\nprint \"No closest item with an ID less than or equal to X exists in the warehouse\", where X is the target ID.\r\n\r\nRefer to the sample output for formatting specifications.\r\n\r\nCode constraints :\r\nIn this scenario, the test cases fall under the following constraints:\r\n1 ≤ N ≤ 10\r\n1 ≤ item ID ≤ 100","language":"plaintext","metadata":{}},{"kind":2,"value":"#include <stdio.h>\r\nint floorBinaryS(int arr[], int low , int high, int x , int ans){\r\n    if (low > high)\r\n    return ans;\r\n    \r\n    int mid = (low + high)/2;\r\n    \r\n    if (arr[mid]==x){\r\n        return arr[mid];\r\n    }\r\n    \r\n    if (arr[mid] < x){\r\n        ans = arr[mid];\r\n    \r\n    return floorBinaryS(arr, mid+1 ,high, x, ans);\r\n    }\r\n    else{\r\n        return floorBinaryS(arr, low, mid-1, x, ans);\r\n    }\r\n    \r\n}\r\nint main(){\r\n    int n;\r\n    scanf(\"%d\", &n);\r\n    \r\n    int arr[n];\r\n    for (int i = 0 ; i < n ; i++){\r\n        scanf(\"%d\", &arr[i]);\r\n    }\r\n    \r\n    int x;\r\n    scanf(\"%d\", &x);\r\n    \r\n    int result = floorBinaryS(arr, 0, n-1, x,-1);\r\n    \r\n    if (result == -1){\r\n        printf(\"No closest item with an ID less than or equal to %d exists in the warehouse\", x);\r\n    }\r\n    else{\r\n        printf(\"The closest item ID less than or equal to %d is %d\",x , result);\r\n    }\r\n    return 0;\r\n}\r\n","language":"c","metadata":{}},{"kind":2,"value":"\r\nQuestion No: 2\r\nSingle File Programming Question\r\nProblem Statement\r\nTom is working in a warehouse inventory system,\r\nwhere the item IDs are assigned sequentially in ascending order. \r\nHe wants to develop a program using recursive binary search to\r\nefficiently determine the closest item ID that is less than or equal\r\nto a given target ID. \r\n\r\nThe program takes the total number of items and their sorted IDs as input,\r\nassisting warehouse staff in quickly identifying the closest available item less than\r\nor equal to the target ID. Help Tom in this program.\r\n\r\nInput format :\r\nThe first line of input consists of an integer N,\r\n representing the number of items in the warehouse.\r\n\r\nThe second line consists of N space-separated integers, \r\nrepresenting the sorted list of item IDs.\r\n\r\nThe third line consists of an integer representing the target item ID.\r\n\r\nOutput format :\r\nThe output prints \"The closest item ID less than or equal to X is Y\", where X is the target ID and Y is the closest item ID less than or equal to X.\r\n\r\nIf no such element exists, print \"No closest item with an ID less than or equal \r\nto X exists in the warehouse\", where X is the target ID.\r\n\r\nCode constraints :\r\nIn this scenario, the test cases fall under the following constraints:\r\n1 ≤ N ≤ 10\r\n1 ≤ item ID ≤ 100\r\n\r\nSample test cases :\r\nInput 1 :\r\n7\r\n17 25 38 47 51 62 79\r\n50\r\nOutput 1 :\r\nThe closest item ID less than or equal to 50 is 47\r\n","language":"plaintext","metadata":{}},{"kind":2,"value":"#include <stdio.h>\r\nint main(){\r\n    int n;\r\n    scanf(\"%d\", &n);\r\n    \r\n    int arr[n];\r\n    for (int i = 0; i < n ; i++){\r\n        scanf(\"%d\", &arr[i]);\r\n    }\r\n    int found = 0;\r\n    for (int i = 0 ; i < n; i++){\r\n        int count = 0;\r\n        for (int j = 0 ; j < n; j++){\r\n            if (arr[i]== arr[j]){\r\n                count ++;\r\n            }\r\n        }\r\n        if (count == 1){\r\n            printf(\"%d\", arr[i]);\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n    if (!found){\r\n        printf(\"No non-duplicate element found\");\r\n    }\r\n    return 0;\r\n}","language":"c","metadata":{}}]}