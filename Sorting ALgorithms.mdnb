{"cells":[{"kind":1,"value":"# **Sorting ALgorithms**","language":"markdown","metadata":{}},{"kind":1,"value":"###  **1. Bubble Sort** ","language":"markdown","metadata":{}},{"kind":2,"value":"Let's sort the list:\r\n [5, 1, 4, 2]\r\n Pass 1:Compare 5 and 1. \r\n (5 > 1), so Swap: [1, 5, 4, 2]\r\n Compare 5 and 4.\r\n (5 > 4), so Swap: [1, 4, 5, 2]\r\n Compare 5 and 2. (5 > 2), \r\n so Swap: [1, 4, 2, 5]\r\n End of Pass 1: \r\n The largest number (5) is now at the end.\r\n\r\n  Pass 2:Compare 1 and 4. (1 < 4),\r\n  No Swap: [1, 4, 2, 5]\r\n  Compare 4 and 2. (4 > 2),\r\n  so Swap: [1, 2, 4, 5]\r\n  End of Pass 2: The next largest number (4) is in place.\r\n\r\n   Pass 3:Compare 1 and 2.\r\n   (1 < 2), No Swap: [1, 2, 4, 5]\r\n   The list is now fully sorted!\r\n   ","language":"plaintext","metadata":{}},{"kind":1,"value":"Efficiency:<br>\r\nWorst Case: $O(n^2)$ (The list is in reverse order). <br>\r\nBest Case: $O(n)$ (The list is already sorted, and we use an \"optimized\" version).<br>\r\n\r\nSpace Complexity: $O(1)$ (It only requires a tiny bit of extra memory to perform the swaps).","language":"markdown","metadata":{}},{"kind":2,"value":"#include <iostream>\r\n#include <vector>\r\n#include <algorithm> // For std::swap\r\n\r\nvoid bubbleSort(std::vector<int>& arr) {\r\n    int n = arr.size();\r\n    bool swapped;\r\n\r\n    for (int i = 0; i < n - 1; i++) {\r\n        swapped = false;\r\n        \r\n        // Inner loop for comparisons\r\n        for (int j = 0; j < n - i - 1; j++) {\r\n            if (arr[j] > arr[j + 1]) {\r\n                std::swap(arr[j], arr[j + 1]);\r\n                swapped = true;\r\n            }\r\n        }\r\n\r\n        // If no two elements were swapped by inner loop, then break\r\n        if (!swapped)\r\n            break;\r\n    }\r\n}\r\n\r\nint main() {\r\n    std::vector<int> data = {64, 34, 25, 12, 22, 11, 90};\r\n    \r\n    bubbleSort(data);\r\n    \r\n    std::cout << \"Sorted array: \";\r\n    for (int num : data) {\r\n        std::cout << num << \" \";\r\n    }\r\n    return 0;\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"### **2. Selection Sort**","language":"markdown","metadata":{}},{"kind":1,"value":"Efficiency:\r\n\r\nBest Case: O(n2),\r\nEven if the list is sorted, it still scans the rest of the list to find the minimum.\r\n\r\nAverage Case:O(n2)  \r\nRequires two nested loops regardless of data distribution.\r\n\r\nWorst Case,O(n2),Same number of comparisons as the best case.\r\n\r\nSpace,O(1),\"It sorts in-place, requiring no extra memory.\"","language":"markdown","metadata":{}},{"kind":2,"value":"Selection Sort Walkthrough\r\nImagine we have the list: [29, 10, 14, 37, 13]\r\nPass 1:\r\nSearch the whole list for the minimum value. We find 10.\r\nSwap 10 with the element in the first position (29).\r\nList becomes: [10, 29, 14, 37, 13]\r\n\r\nPass 2:\r\nSearch the remaining unsorted part ([29, 14, 37, 13]) for the minimum. We find 13.\r\nSwap 13 with the element in the second position (29).\r\nList becomes: [10, 13, 14, 37, 29]\r\n\r\nPass 3:\r\nSearch [14, 37, 29] for the minimum. It's already 14.\r\nNo swap needed (or swap 14 with itself).\r\nList remains: [10, 13, 14, 37, 29]\r\n\r\nPass 4:\r\nSearch [37, 29] for the minimum. We find 29.\r\nSwap 29 with 37.\r\n\r\nList becomes: [10, 13, 14, 29, 37]","language":"plaintext","metadata":{}},{"kind":2,"value":"\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm> // For std::swap\r\n\r\nvoid selectionSort(std::vector<int>& arr) {\r\n    int n = arr.size();\r\n\r\n    // One by one move the boundary of the unsorted subarray\r\n    for (int i = 0; i < n - 1; i++) {\r\n        // Find the minimum element in unsorted array\r\n        int min_idx = i;\r\n        for (int j = i + 1; j < n; j++) {\r\n            if (arr[j] < arr[min_idx]) {\r\n                min_idx = j;\r\n            }\r\n        }\r\n\r\n        // Swap the found minimum element with the first element\r\n        if (min_idx != i) {\r\n            std::swap(arr[i], arr[min_idx]);\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    std::vector<int> data = {29, 10, 14, 37, 13};\r\n    \r\n    selectionSort(data);\r\n    \r\n    std::cout << \"Sorted array: \";\r\n    for (int num : data) {\r\n        std::cout << num << \" \";\r\n    }\r\n    return 0;\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"### **3.Insertion Sort**","language":"markdown","metadata":{}},{"kind":1,"value":"Insertion Sort builds the final sorted array one item at a time. Itâ€™s very much like how you might sort a hand of playing cards: you take one card and shift the others until you find the right \"slot\" to insert it.","language":"markdown","metadata":{}},{"kind":2,"value":"Example Walkthrough: \r\n[5, 2, 4, 1]\r\nStart at the second element (2): \r\nIs 2 < 5? Yes. \r\nShift 5 to the right and insert 2.\r\n[2, 5, 4, 1]\r\nNext element (4):\r\n Is 4 < 5? Yes.\r\n Shift 5 to the right. \r\n Is 4 < 2? No. Insert 4 after 2.[2, 4, 5, 1]\r\n Next element (1): Is $1 < 5$? Yes. \r\n Shift 5. \r\n Is 1 < 4? Yes. \r\n Shift 4. \r\n Is 1 < 2? \r\n Yes. \r\n Shift 2. \r\n Insert 1 at the beginning.[1, 2, 4, 5]","language":"plaintext","metadata":{}},{"kind":1,"value":"Key Complexities \r\n\r\nTime Complexity: \r\n\r\n$O(n^2)$ worst case,\r\n\r\nbut $O(n)$ if the list is already sorted!\r\n\r\n\r\nSpace Complexity: $O(1)$ (In-place).\r\n\r\nBest Use Case: Great for small datasets or lists that are \"nearly sorted.\"","language":"markdown","metadata":{}},{"kind":2,"value":"void insertionSort(std::vector<int>& arr) {\r\n    int n = arr.size();\r\n    for (int i = 1; i < n; i++) {\r\n        int key = arr[i]; // The \"card\" we are currently inserting\r\n        int j = i - 1;\r\n\r\n        // Move elements of arr[0..i-1] that are greater than key\r\n        // to one position ahead of their current position\r\n        while (j >= 0 && arr[j] > key) {\r\n            arr[j + 1] = arr[j];\r\n            j--;\r\n        }\r\n        arr[j + 1] = key;\r\n    }\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"### **4.Counting Sort**","language":"markdown","metadata":{}},{"kind":2,"value":"Example Walkthrough: [1, 4, 1, 2, 7]\r\nCount occurrences:\r\n\r\n1 appears 2 times.\r\n2 appears 1 time.\r\n4 appears 1 time.\r\n7 appears 1 time.\r\n\r\nCumulative Count: Add the counts up to know the positions. \r\n(e.g., since there are two 1s, the number 2 must start at index 2).\r\n\r\nPlace elements: Use the count table to put numbers into a new output array.","language":"plaintext","metadata":{}},{"kind":2,"value":"void countingSort(std::vector<int>& arr) {\r\n    if (arr.empty()) return;\r\n    int maxVal = *max_element(arr.begin(), arr.end());\r\n    std::vector<int> count(maxVal + 1, 0);\r\n    std::vector<int> output(arr.size());\r\n\r\n    for (int x : arr) count[x]++;\r\n    for (int i = 1; i <= maxVal; i++) count[i] += count[i - 1];\r\n    \r\n    for (int i = arr.size() - 1; i >= 0; i--) {\r\n        output[count[arr[i]] - 1] = arr[i];\r\n        count[arr[i]]--;\r\n    }\r\n    arr = output;\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"Key Complexities \r\n\r\nTime Complexity:\r\n$O(n + k)$, where $k$ is the range of the input numbers.\r\n\r\nConstraint: It only works with integers and becomes very memory-heavy if the range ($k$) is huge (e.g., trying to sort [1, 1000000000]).","language":"markdown","metadata":{}},{"kind":1,"value":"### **5. Radix Sort**","language":"markdown","metadata":{}},{"kind":1,"value":"Radix Sort avoids comparisons by processing digits. It typically starts from the Least Significant Digit (the ones place) and moves toward the Most Significant Digit. It uses a stable sorting algorithm (like Counting Sort) as a subroutine for each digit.\r\n","language":"markdown","metadata":{}},{"kind":2,"value":"\r\nExample Walkthrough: \r\n[170, 45, 75, 90]\r\nSort by ones place: [170, 90, 45, 75] (0, 0, 5, 5)\r\n\r\nSort by tens place: [45, 75, 170, 90] (4, 7, 7, 9)\r\n\r\nSort by hundreds place: [045, 075, 090, 170] (0, 0, 0, 1)","language":"plaintext","metadata":{}},{"kind":2,"value":"// Helper function to do counting sort based on the digit represented by 'exp'\r\nvoid countSortForRadix(std::vector<int>& arr, int exp) {\r\n    int n = arr.size();\r\n    std::vector<int> output(n);\r\n    int count[10] = {0};\r\n\r\n    for (int i = 0; i < n; i++) count[(arr[i] / exp) % 10]++;\r\n    for (int i = 1; i < 10; i++) count[i] += count[i - 1];\r\n\r\n    for (int i = n - 1; i >= 0; i--) {\r\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\r\n        count[(arr[i] / exp) % 10]--;\r\n    }\r\n    arr = output;\r\n}\r\n\r\nvoid radixSort(std::vector<int>& arr) {\r\n    int maxVal = *max_element(arr.begin(), arr.end());\r\n    // Run countSort for every digit (1s, 10s, 100s...)\r\n    for (int exp = 1; maxVal / exp > 0; exp *= 10)\r\n        countSortForRadix(arr, exp);\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"Key Complexities \r\nTime Complexity:\r\n\r\n$O(d \\cdot (n + k))$, \r\n\r\nwhere $d$ is the number of digits and $k$ is the base (usually 10).\r\n\r\n\r\nSpace Complexity: $O(n + k)$.\r\n\r\nNote: It is extremely fast for fixed-length integers but doesn't work well for floating-point numbers or strings of varying lengths without modification.","language":"markdown","metadata":{}},{"kind":1,"value":"### **6. Bucket Sort**","language":"markdown","metadata":{}},{"kind":1,"value":"Bucket Sort is a \"divide and conquer\" strategy. It distributes elements into several \"buckets,\" sorts each bucket individually (often using Insertion Sort), and then merges them back together. It's best when input is uniformly distributed over a range.","language":"markdown","metadata":{}},{"kind":1,"value":"Example Walkthrough: \r\n[0.42, 0.32, 0.33, 0.52]\r\n\r\nCreate Buckets: \r\n\r\nCreate 10 buckets (indices 0-9).\r\n\r\nDistribute:0.32 and 0.33 go into Bucket 3.\r\n\r\n0.42 goes into Bucket 4.\r\n\r\n0.52 goes into Bucket 5.\r\n\r\n\r\nSort Buckets: Sort Bucket 3 $\\rightarrow$ [0.32, 0.33].\r\n\r\nGather: Concatenate all non-empty buckets. [0.32, 0.33, 0.42, 0.52]","language":"markdown","metadata":{}},{"kind":2,"value":"void bucketSort(std::vector<float>& arr) {\r\n    int n = arr.size();\r\n    std::vector<float> buckets[n];\r\n\r\n    // 1. Put elements in different buckets\r\n    for (int i = 0; i < n; i++) {\r\n        int bi = n * arr[i]; // Index in bucket\r\n        buckets[bi].push_back(arr[i]);\r\n    }\r\n\r\n    // 2. Sort individual buckets\r\n    for (int i = 0; i < n; i++)\r\n        std::sort(buckets[i].begin(), buckets[i].end());\r\n\r\n    // 3. Concatenate all buckets into arr[]\r\n    int index = 0;\r\n    for (int i = 0; i < n; i++)\r\n        for (size_t j = 0; j < buckets[i].size(); j++)\r\n            arr[index++] = buckets[i][j];\r\n}","language":"cpp","metadata":{}},{"kind":1,"value":"Key Complexities \r\n\r\nAverage Time: $O(n + k)$ (assuming uniform distribution)\r\nWorst Case: $O(n^2)$ (if all elements fall into one bucket).\r\n\r\nBest Use Case: Sorting floating-point numbers that are evenly spread across a range (like 0.0 to 1.0).","language":"markdown","metadata":{}},{"kind":1,"value":"| Algorithm | Type  | Time Complexity (Average)  | Space Complexity  | Best For...  |\r\n| :--- | :--- | :--- | :--- | :--- |\r\n| **Bubble Sort** | Comparison | $O(n^2)$ | $O(1)$ | Small, nearly sorted lists |\r\n| **Selection Sort** | Comparison | $O(n^2)$ | $O(1)$ | Minimizing memory swaps |\r\n| **Insertion Sort** | Comparison | $O(n^2)$ | $O(1)$ | Real-time or small datasets |\r\n| **Counting Sort** | Non-Comparison | $O(n + k)$ | $O(k)$ | Small range of integers |\r\n| **Radix Sort** | Non-Comparison | $O(d \\cdot (n + k))$ | $O(n + k)$ | Large integers / Fixed-width data |\r\n| **Bucket Sort** | Distribution | $O(n + k)$ | $O(n + k)$ | Uniformly distributed decimals |","language":"markdown","metadata":{}},{"kind":1,"value":"","language":"markdown","metadata":{}}]}